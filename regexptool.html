<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Regular expression tool</title>
		<style type="text/css">
		/*<![CDATA[*/
			/*
			https://kuler.adobe.com/#themeID/2244541
			#FFFFED
			#FF2C38
			#FF9A3A
			#FFF040
			#67D9FF
			
			https://kuler.adobe.com/#themeID/238698
			#88A825
			#35203B
			#911146
			#CF4A30
			#ED8C2B
			
			#fff000
			#80c0ff
			#aad1f7
			#f9ca69
			#f7a700
			#efba4a
			#d2f854
			#9ec70c
			#ecc9f7
			#54b70b
			#b688cf
			 */
			@font-face {
				font-family: 'BitstreamVeraSansMonoRoman';
				src: url('font/VeraMono-webfont.woff') format('woff');
				font-weight: normal;
				font-style: normal;
			}
			
			html{
				font-size: 0.8em;
				font-family: sans-serif;
			}
			
			#regexp, #replacePattern, #text{
				resize: vertical;
				
				display :block;
				-moz-box-sizing: border-box;
				box-sizing: border-box;
				-moz-appearance: textfield-multiline;
				appearance: textfield-multiline;
				width: 100%;
				padding: 4px;
				outline: none;
			
				font-family: 'BitstreamVeraSansMonoRoman', monospace;
			    font-size: 0.8rem;
			    font-size-adjust: none;
			    font-stretch: normal;
			    font-style: normal;
			    font-variant: normal;
			    font-weight: normal;
			    letter-spacing: normal;
			    line-height: normal;
				margin: 1px 0;
			
				overflow: auto;
			
				white-space: pre;
			}
			#text{
				min-height: 100px;
				background: #CCCCCC;
			}
			.options{
				display: inline-block;
			}
			.match{
				display: inline-block;
				background: white;
				padding: 1px 2px;
				margin: -1px -2px;
				box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.5);
			}
			.match:hover{
				animation: match-zoom 0.2s;
				border-radius: 6px;
				margin: -2px -4px;
				padding: 1px 3px;
				background: #ff9430;
				background: linear-gradient(to bottom, #ff9430 0%,#ea862e 100%);
				border: 1px solid #ff9430;
			}
			@keyframes match-zoom{
				from{
					transform: scale(1.07, 1.07);
				}to{
					transform: scale(1, 1);
				}
			}
			.capture{
				display: inline-block;
			}
			.capture:hover{
				color: #020202;
				/*background: #ED8C2B;
				border-radius: 2px;*/
			}
			#output{
				resize: vertical;
				
				display :block;
				-moz-box-sizing: border-box;
				box-sizing: border-box;
				width: 100%;
				min-height: 100px;
				padding: 4px;
			
				font-family: 'BitstreamVeraSansMonoRoman', monospace;
			    font-size: 0.8rem;
			    font-size-adjust: none;
			    font-stretch: normal;
			    font-style: normal;
			    font-variant: normal;
			    font-weight: normal;
			    letter-spacing: normal;
			    line-height: normal;
				margin: 1px 0;
			
				overflow: auto;
			
				white-space: pre;

				background: #CCCCCC;
			}
		/*]>*/
		</style>
		<script type="text/javascript">
		/*<![CDATA[*/
			"use strict";
			
			var RegExpFlag = Object.freeze({
				GLOBAL: "g",
				IGNORE_CASE: "i",
				MULTILINE: "m"
			});
			
			var RegExpTool = function RegExpTool(doc){
				doc.addEventListener("DOMContentLoaded", this._domLoadedListener.bind(this), false);
			}
			RegExpTool.prototype = Object.seal({
				_regExpSrc: "",
				_regExp: null,
				_globalOpt: false,
				_caseOpt: false,
				_lineOpt: false,
				_replaceOpt: false,
				_extractOpt: false,
				_replacePattern: "",
				_text: "",
				_modeElm: null,
				_regExpElm: null,
				_globalOptElm: null,
				_caseOptElm: null,
				_lineOptElm: null,
				_replacePatternElm: null,
				_textElm: null,
				_outputElm: null,
				_matches: [],
				_domLoadedListener: function(event){
					
					this._regExpElm = document.getElementById("regexp");
					this._regExpElm.addEventListener("change", this._inputListener.bind(this), false);
					this._regExpElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._regExpElm);
					
					this._globalOptElm = document.getElementById("globalOpt");
					this._globalOptElm.addEventListener("change", this._inputListener.bind(this), false);
					this._globalOptElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._globalOptElm);
					
					this._caseOptElm = document.getElementById("caseOpt");
					this._caseOptElm.addEventListener("change", this._inputListener.bind(this), false);
					this._caseOptElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._caseOptElm);
					
					this._lineOptElm = document.getElementById("lineOpt");
					this._lineOptElm.addEventListener("change", this._inputListener.bind(this), false);
					this._lineOptElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._lineOptElm);
					
					this._replaceOptElm = document.getElementById("replaceOpt");
					this._replaceOptElm.addEventListener("change", this._inputListener.bind(this), false);
					this._replaceOptElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._replaceOptElm);
					
					this._extractOptElm = document.getElementById("extractOpt");
					this._extractOptElm.addEventListener("change", this._inputListener.bind(this), false);
					this._extractOptElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._extractOptElm);
					
					this._replacePatternElm = document.getElementById("replacePattern");
					this._replacePatternElm.addEventListener("change", this._inputListener.bind(this), false);
					this._replacePatternElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._replacePatternElm);
					
					this._textElm = document.getElementById("text");
					this._textElm.addEventListener("change", this._inputListener.bind(this), false);
					this._textElm.addEventListener("input", this._inputListener.bind(this), false);
					this._setByInput(this._textElm);
					
					this._outputElm = document.getElementById("output");
					
					this.exec();
				},
				/*
				Replace all br in given element with a textnode contains "\n"
				Usefull when you want the text of a node via textContent. Basically textContent remove all tags include br, but dont replace this ones by "\n".
				*/
				_replaceAllBr: function(element){
					var nodes = element.getElementsByTagName("br"), node, textNode;
					//nodes is a living list (updated when a node appears or disappears)
					while(nodes.length > 0){
						node = nodes[0];
						textNode = textNode != null ? textNode.cloneNode() : document.createTextNode("\n");
						node.parentNode.replaceChild(textNode, node);
					}
				},
				_setByInput: function(element){
					var regExpUpdateRequired = false;
					var patternTokenizer;
					var flags = "";
					var regExpError = null;
					
					switch(element){
						case this._regExpElm:
							this._regExpSrc = this._regExpElm.value;
							regExpUpdateRequired = true;
							break;
						case this._globalOptElm:
							this._globalOpt = this._globalOptElm.checked;
							regExpUpdateRequired = true;
							break;
						case this._caseOptElm:
							this._caseOpt = this._caseOptElm.checked;
							regExpUpdateRequired = true;
							break;
						case this._lineOptElm:
							this._lineOpt = this._lineOptElm.checked;
							regExpUpdateRequired = true;
							break;
						case this._replaceOptElm:
							this._replaceOpt = this._replaceOptElm.checked;
							break;
						case this._extractOptElm:
							this._extractOpt = this._extractOptElm.checked;
							break;
						case this._replacePatternElm:
							this._replacePattern = this._replacePatternElm.value;
							break;
						case this._textElm:
							this._replaceAllBr(this._textElm);
							this._text = this._textElm.textContent;
							break;
					}
					
					//End here if no updated required
					if(!regExpUpdateRequired || this._regExp == null && element != this._regExpElm){
						return;
					}
					
					if(this._globalOpt){
						flags += RegExpFlag.GLOBAL;
					}
					if(!this._caseOpt){
						flags += RegExpFlag.IGNORE_CASE;
					}
					if(this._lineOpt){
						flags += RegExpFlag.MULTILINE;
					}
					
					if(this._regExpSrc == ""){
						regExpError = new Error("empty field");
						regExpError.name = "CustomValidityError";
					}else{
						try{
							this._regExp = new RegExp(this._regExpSrc, flags);
						}catch(error){
							regExpError = error;
						}
					}					
					if(regExpError != null){
						this._regExp = null;
						this._regExpElm.setCustomValidity(regExpError.message);
					}else{
						//erase the validity message
						this._regExpElm.setCustomValidity("");
					}
				},
				_inputListener: function(event){
					this._setByInput(event.currentTarget);					
					this.exec();
				},
				_updateMatches: function(){
					var regExp = this._regExp,
						str = this._text,
						result,
						matches = this._matches;
					//reset matches array
					matches.length = 0;
					
					if(regExp == null){
						//End
						return;
					}
					
					//reset lastIndex
					regExp.lastIndex = 0;
					
					//If not iterative regexp, only match first one
					if(!regExp.global){
						result = regExp.exec(str);
						if(result != null){
							matches.push(result);
						}
						//End
						return;
					}
					
					while(true){
						result = regExp.exec(str);
						if(result != null){
							matches.push(result);
						}else{
							break;
						}
					}
				},
				_updateHighlights: function(){
					var textElm = this._textElm,
						matches = this._matches,
						nodes = document.createDocumentFragment(),
						node,
						matchIndex,
						matchCount = matches.length,
						text = this._text,
						match,
						matchStr,
						matchStartIndex,
						matchLength,
						captureCount,
						title,
						captureIndex;
					
					//TODO save selection
					
					//Remove current content
					while (textElm.firstChild) {
						textElm.removeChild(textElm.firstChild);
					}
					
					if(matchCount >= 1){
						//add portion of the string that precedes the first match 
						nodes.appendChild(document.createTextNode(text.substring(0, matches[0].index)));
					}else{
						//Add all
						nodes.appendChild(document.createTextNode(text));
					}
					
					for(matchIndex = 0; matchIndex < matchCount; matchIndex++){
						match = matches[matchIndex];
						matchStr = match[0];
						matchStartIndex = match.index;
						matchLength = matchStr.length;
						captureCount = match.length - 1;
						node = document.createElement("span");
						node.className = "match";
						title = "match: " + matchStr + "\nindex: " + matchStartIndex + "\nlength: " + matchLength + "\ngroups: " + captureCount;
						for(captureIndex = 0; captureIndex < captureCount; captureIndex++){
							title += "\n\tgroup " + captureIndex + ": " + match[captureIndex + 1];
						}
						node.title = title;
						node.appendChild(document.createTextNode(matchStr));
						nodes.appendChild(node);
						
						if(matchIndex < matchCount - 1){
							//add portion of the string that follows the match to the next one
							nodes.appendChild(document.createTextNode(text.substring(matchStartIndex + matchLength, matches[matchIndex + 1].index)));
						}else{
							//add portion of the string that follows the last match
							nodes.appendChild(document.createTextNode(text.substring(matchStartIndex + matchLength)));
						}
					}
					
					this._textElm.appendChild(nodes);
					//TODO restore selection
				},
				/*
				Inspired from Tamarin String().replace()
				See http://hg.mozilla.org/tamarin-central/file/fbecf6c8a86f/core/RegExpObject.cpp RegExpObject::replace
				I identify one bug in this implementation when you use "capture1".replace(/(capture1)/g, "$01") will return "capture11" instead of "capture1"
				
				Others implementations : 
				http://code.google.com/p/v8/source/browse/trunk/src/string.js#318
				https://github.com/mozilla/rhino/blob/master/src/org/mozilla/javascript/regexp/RegExpImpl.java#L351
				https://github.com/mozilla/rhino/blob/master/src/org/mozilla/javascript/regexp/NativeRegExpCtor.java
				http://hg.mozilla.org/mozilla-central/file/06935f2db267/js/src/jsstr.cpp#l2277 http://mxr.mozilla.org/mozilla-central/source/js/src/jsstr.cpp#2277
				
				Also it convert "$nn" to "$n" when "nn" < 10 (ex.: "05"->"5")
				*/
				_getSlices: function(replacePattern, captureCount){
					var slices = [];
					var char,
						charIndex,
						charCount = replacePattern.length,
						captureIndex,
						digitLength,
						bufferPos = 0,
						bufferLength = 0;//capture index is between 1 and captureCount (inclusive)
					
					charIndex = 0;
					while(charIndex < charCount){
						char = replacePattern.charAt(charIndex);
						//if start with $ and has one more char
						if(char == "$" && charIndex + 1 < charCount){
							//next char
							switch(replacePattern.charAt(charIndex + 1)){
								//$n or $nn
								case "0":
								case "1":
								case "2":
								case "3":
								case "4":
								case "5":
								case "6":
								case "7":
								case "8":
								case "9":{
									//digitLength is the change with original implentation
									
									//has one more char again and is 0 to 9
									if(charIndex + 2 < charCount && replacePattern.charAt(charIndex + 2) >= "0" && replacePattern.charAt(charIndex + 2) <= "9"){
										captureIndex = 10 * (replacePattern.charAt(charIndex + 1) - "0") + (replacePattern.charAt(charIndex + 2) - "0");
										digitLength = 2;
										if(captureIndex > captureCount){
											//juste take account one digit
											captureIndex = replacePattern.charAt(charIndex + 1) - "0";
											digitLength = 1;
										}
									}else{
										captureIndex = replacePattern.charAt(charIndex + 1) - "0";
										digitLength = 1;
									}
									if(captureIndex >= 1 && captureIndex <= captureCount){
										//add previous slice
										if(bufferLength > 0){
											slices.push(replacePattern.substr(bufferPos, bufferLength));
											//clear buffer
											bufferLength = 0;
										}
										//add result
										//replace $01 to $1
										slices.push("$" + captureIndex);
										charIndex += 1 + digitLength;
										bufferPos = charIndex;
									}
									//not valid captureIndex
									else{
										charIndex++;
										bufferLength++;
									}
									break;	
								}
								//others
								case "$":
								case "&":
								case "`":
								case "'":{
									//add previous slice
									if(bufferLength > 0){
										slices.push(replacePattern.substr(bufferPos, bufferLength));
										//clear buffer
										bufferLength = 0;
									}
									//add result
									slices.push(replacePattern.substring(charIndex, charIndex +2));
									charIndex += 2;
									bufferPos = charIndex;
									break;
								}
								default:
									charIndex++;
									bufferLength++;
									break;
							}
						}else{
							charIndex++;
							bufferLength++;		
						}
					}
					
					//if has buffer
					if(bufferLength > 0){
						slices.push(replacePattern.substr(bufferPos, bufferLength));
						//clear buffer
						bufferLength = 0;
					}
					
					return slices;
				},
				//look like the same as _updateHighlights() but it's far more complex
				_updateOutput: function(){
					var outputElm = this._outputElm,
						matches = this._matches,
						replace = this._replaceOpt,
						extract = this._extractOpt,
						replacePattern = this._replacePattern,
						index,
						nodes = document.createDocumentFragment(),
						node,
						matchCount = matches.length,
						text = this._text,
						textLength = text.length,
						match,
						matchStr,
						matchIndex,
						matchLength,
						nextMatchIndex,
						captureCount,
						capture,
						slices = [],
						slice,
						sliceCount,
						patterns,
						subIndex,
						subNode;
					
					//Remove current content
					while (outputElm.firstChild) {
						outputElm.removeChild(outputElm.firstChild);
					}
					
					//one or more matches
					if(matchCount >= 1){
						//first match
						match = matches[0];
						captureCount = match.length - 1;
						slices = this._getSlices(replacePattern, captureCount);
						//update replacePattern with parsed result, $nn could be changed to $n when nn is less than 10
						replacePattern = slices.join("");
						sliceCount = slices.length;
						
						//only if match don't start at index 0
						if(match.index > 0 && !extract){
							//add portion of the string that precedes the first match 
							nodes.appendChild(document.createTextNode(text.substring(0, match.index)));
						}
					}else if(!extract){
						//Add all
						nodes.appendChild(document.createTextNode(text));
					}
					
					//for each matches
					for(index = 0; index < matchCount; index++){
						match = matches[index];
						matchStr = match[0];
						matchIndex = match.index;
						matchLength = matchStr.length;
						nextMatchIndex = index < matchCount - 1 ? matches[index + 1].index : text.length;
						captureCount = match.length - 1;
						node = document.createElement("span");
						node.className = "match";
						if(replace){
							node.title = "match: " + matchStr + "\nindex: " + matchIndex + "\nreplace: " + replacePattern;
							
							patterns = {
								"$$": "$",
								"$`": text.substring(0, matchIndex),
								"$'": text.substring(matchIndex + matchLength, textLength),
								"$&": matchStr
							};
							for(subIndex = 0; subIndex < captureCount; subIndex++){
								capture = match[subIndex + 1];
								patterns["$" + (subIndex + 1)] = capture;
								node.title += "\n\tcapture" + subIndex + ": " + capture;
							}
							
							for(subIndex = 0; subIndex < sliceCount; subIndex++){
								slice = slices[subIndex];
								if(slice in patterns){
									subNode = document.createElement("span");
									subNode.className = "capture";
									subNode.title = "replace: " + replacePattern + "\n\tcapture: " + patterns[slice] + "\n\tpattern: " + slice;
									subNode.appendChild(document.createTextNode(patterns[slice]));
									node.appendChild(subNode);
								}else{
									node.appendChild(document.createTextNode(slice));
								}
							}
						}else{
							node.appendChild(document.createTextNode(matchStr));
						}
						nodes.appendChild(node);
						
						if(!extract){
							//add portion of the string that follows the match to the next one (or to the end)
							nodes.appendChild(document.createTextNode(text.substring(matchIndex + matchLength, nextMatchIndex)));
						}
					}
					
					this._outputElm.appendChild(nodes);
				},
				exec: function(){
					this._updateMatches();
					this._updateHighlights();
					this._updateOutput();
				}
			});
			Object.freeze(RegExpTool);
		
			/**
			Main
			**/
			
			var regExpTool = new RegExpTool(document);
		/*]>*/
		</script>
	</head>
	<body>
		<div>
			<form id="regexFrom">
				<p class="input-field regexp">
					<label for="regexp">Regular expression</label>
					<!-- <a href=\"(.*)\">(.*)<\/a> -->
					<input id="regexp" type="text" required="required" placeholder="&lt;a href=&quot;([^&quot;]*)&quot;&gt;([^&lt;]*)&lt;\/a&gt;" value="&lt;a href=&quot;([^&quot;]*)&quot;&gt;([^&lt;]*)&lt;\/a&gt;" />
				</p>
				<p class="input-field options">
					<input id="globalOpt" type="checkbox" />
					<label for="globalOpt" title="Enable global matching. So multiple matches can be found.">Iterative (matches more than one)</label>
				</p>
				<p class="input-field options">
					<input id="caseOpt" type="checkbox" />
					<label for="caseOpt" title="Enable case sensistive matching.">Case sensitive</label>
				</p>
				<p class="input-field options">
					<input id="lineOpt" type="checkbox" />
					<label for="lineOpt" title="Enable match on each line (i.e., each portion of text separated by \r or \n.)">Per line matching</label>
				</p>
				<!--
				<p class="input-field options">
					<input id="whiteSpaceOpt" type="checkbox" title="Ignores white space characters in the expression. Useful for formatting long expressions." />
					<label for="whiteSpaceOpt">Ignore white space</label>
				</p>
				<p class="input-field options">
					<input id="dotAllOpt" type="checkbox" title="Enable &quot;.&quot; matches new-lines characters" />
					<label for="dotAllOpt">Dot is all</label>
					</p>-->
				<p class="input-field options">
					<input id="replaceOpt" type="checkbox" />
					<label for="replaceOpt" title="Replace matched">Replace with pattern</label>
				</p>
				<p class="input-field options">
					<input id="extractOpt" type="checkbox" />
					<label for="extractOpt" title="Output only matched result using defined pattern.">Only matches</label>
				</p>
				<p class="input-field replacePattern">
					<label for="replacePattern">Pattern</label>
					<textarea id="replacePattern" placeholder="[$1 $2]">[$1 $2]</textarea>
				</p>
				<p class="input-field text">
					<label for="text">Input</label>
				</p>
				<!-- Don't use contenteditable="true" on inline elements, weird behavior occurs when pasting HTML (with FF, others ?) -->
				<div id="text" contenteditable="true" required="required">He's goin' everywhere, &lt;a href=&quot;http://www.bjmckay.com&quot;&gt;B.J. McKay&lt;/a&gt; and his best friend Bear. Rollin' down to &lt;a href=&quot;http://www.dallas.net&quot;&gt;Dallas&lt;/a&gt;, who's providin' my palace, off to New Orleans or who knows where.</div>
				<p>
					<label>Output</label>
					<output id="output" for="regexp globalOpt caseOpt lineOpt replaceOpt extractOpt replacePattern text"></output>
				</p>
			</form>
		</div>
	</body>
</html>